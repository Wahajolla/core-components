{"version":3,"file":"6655.1ac59cf9.iframe.bundle.js","mappings":"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","sources":["webpack://@alfalab/core-components/./packages/day-of-month-picker/node_modules/@alfalab/hooks/dist/esm/index.js","webpack://@alfalab/core-components/./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://@alfalab/core-components/./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://@alfalab/core-components/./node_modules/intersection-observer/intersection-observer.js","webpack://@alfalab/core-components/./node_modules/querystring/decode.js","webpack://@alfalab/core-components/./node_modules/querystring/encode.js","webpack://@alfalab/core-components/./node_modules/querystring/index.js"],"sourcesContent":["import React, { useRef, useState, useCallback, useEffect, useLayoutEffect } from 'react';\nimport { hasScrolledToBottomOfPage } from '@alfalab/utils';\nimport { v4 } from 'uuid';\n\nfunction useClickOutside(ref, cb) {\n    React.useEffect(function () {\n        var handler = function (event) {\n            var checkClickedElement = function (el) {\n                return !el.current || el.current.contains(event.target);\n            };\n            if ((Array.isArray(ref) && ref.find(checkClickedElement)) ||\n                (!Array.isArray(ref) && checkClickedElement(ref))) {\n                return;\n            }\n            cb(event);\n        };\n        document.addEventListener('mousedown', handler);\n        document.addEventListener('touchstart', handler);\n        return function () {\n            document.removeEventListener('mousedown', handler);\n            document.removeEventListener('touchstart', handler);\n        };\n    }, [ref, cb]);\n}\n\n/**\n * Хук обратного отсчёта времени.\n * Возвращает оставшееся количество секунд до определённой даты.\n *\n * @param params.endDate - Дата окончания\n * @param params.onStart - Функция, которая будет вызвана при запуске счётчика\n * @param params.onEnd - Функция, которая будет вызвана при окончании счётчика\n */\nfunction useCountdown(_a) {\n    var endDate = _a.endDate, onStart = _a.onStart, onEnd = _a.onEnd;\n    var intervalId = useRef(null);\n    var _b = useState(differenceInSeconds(endDate, new Date())), seconds = _b[0], setSeconds = _b[1];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    var clear = useCallback(function () { return clearInterval(intervalId.current); }, []);\n    useEffect(function () {\n        if (onStart) {\n            onStart();\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useEffect(function () {\n        intervalId.current = setInterval(function () {\n            setSeconds(function (sec) { return sec - 1; });\n        }, 1000);\n        return clear;\n    }, [clear]);\n    useEffect(function () {\n        if (seconds <= 0) {\n            clear();\n            if (onEnd) {\n                onEnd();\n            }\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [seconds]);\n    return [seconds];\n}\nfunction differenceInSeconds(dateLeft, dateRight) {\n    var diff = (dateLeft.getTime() - dateRight.getTime()) / 1000;\n    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);\n}\n\nfunction getDimensionObject(node) {\n    return node.getBoundingClientRect();\n}\nfunction useDimensions(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.liveMeasure, liveMeasure = _c === void 0 ? true : _c;\n    var _d = useState(), dimensions = _d[0], setDimensions = _d[1];\n    var _e = useState(), node = _e[0], setNode = _e[1];\n    var ref = useCallback(function (_node) {\n        setNode(_node);\n    }, []);\n    useLayoutEffect(function () {\n        if (node) {\n            var measure_1 = function () {\n                return window.requestAnimationFrame(function () { return setDimensions(getDimensionObject(node)); });\n            };\n            measure_1();\n            if (liveMeasure) {\n                window.addEventListener('resize', measure_1);\n                window.addEventListener('scroll', measure_1);\n                return function () {\n                    window.removeEventListener('resize', measure_1);\n                    window.removeEventListener('scroll', measure_1);\n                };\n            }\n        }\n        return function () { return undefined; };\n    }, [node, liveMeasure]);\n    return [ref, dimensions, node];\n}\n\n/**\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\n *\n * @param {function} fn\n */\nfunction useEventCallback(fn) {\n    var ref = React.useRef(fn);\n    React.useEffect(function () {\n        ref.current = fn;\n    });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    return React.useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (ref.current).apply(void 0, args);\n    }, []);\n}\n\nvar prevInputMethod;\nfunction handleKeyDown(event) {\n    if (event.key === 'Tab') {\n        prevInputMethod = 'keyboard';\n    }\n}\nfunction handleMouseDown() {\n    prevInputMethod = 'mouse';\n}\nfunction handleTouchStart() {\n    prevInputMethod = 'mouse';\n}\n/**\n * Навешивает несколько глобальных обработчиков и отслеживает метод ввода - мышь или клавиатура.\n * Note: Повторный вызов функции не дублирует обработчики\n */\nfunction addGlobalListeners() {\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('touchstart', handleTouchStart);\n}\n/**\n * Хук устанавливает обработчик события на focusin и focusout\n * по конкретному типу события\n * @param node Элемент на котором установится обработчик (default = document)\n * @param inputMethod Если параметр не задан, установит обработчик по любому событию фокуса\n */\nfunction useFocus(ref, inputMethod) {\n    var _a = React.useState(false), focus = _a[0], setFocus = _a[1];\n    var handleFocus = React.useCallback(function () {\n        if (!inputMethod || inputMethod === prevInputMethod) {\n            setFocus(true);\n        }\n    }, [inputMethod]);\n    var handleBlur = React.useCallback(function () {\n        setFocus(false);\n    }, []);\n    React.useEffect(function () {\n        var node = ref.current;\n        if (node) {\n            node.addEventListener('focusin', handleFocus);\n            node.addEventListener('focusout', handleBlur);\n        }\n        return function () {\n            if (node) {\n                node.removeEventListener('focusin', handleFocus);\n                node.removeEventListener('focusout', handleBlur);\n            }\n        };\n    }, [handleBlur, handleFocus, ref]);\n    React.useEffect(addGlobalListeners, []);\n    return [focus];\n}\n\nfunction useKeydownOutside(ref, cb) {\n    React.useEffect(function () {\n        var handler = function (event) {\n            if (!ref.current || (event.target instanceof Node && ref.current.contains(event.target))) {\n                return;\n            }\n            cb(event);\n        };\n        document.addEventListener('keydown', handler);\n        return function () {\n            document.removeEventListener('keydown', handler);\n        };\n    }, [ref, cb]);\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nfunction getValue(list) {\n    return list.map(\n    // eslint-disable-next-line no-confusing-arrow\n    function (_a) {\n        var value = _a[0], query = _a[1];\n        return query.matches ? value : null;\n    }).filter(Boolean);\n}\nfunction useMedia(list, defaultValue) {\n    var _a = React.useState([defaultValue]), value = _a[0], setValue = _a[1];\n    var _b = React.useState([]), mediaQueryList = _b[0], setMediaQueryList = _b[1];\n    var isClient = typeof window !== 'undefined';\n    React.useEffect(function () {\n        if (isClient && window.matchMedia) {\n            var queryList = list.map(function (_a) {\n                var x = _a[0], y = _a[1];\n                return [x, window.matchMedia(y)];\n            });\n            setMediaQueryList(queryList);\n            setValue(getValue(queryList));\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isClient]);\n    React.useEffect(function () {\n        var handler = function () {\n            setValue(getValue(mediaQueryList));\n        };\n        mediaQueryList.forEach(function (_a) {\n            _a[0]; var mediaQuery = _a[1];\n            return mediaQuery.addListener(handler);\n        });\n        return function () {\n            mediaQueryList\n                .forEach(function (_a) {\n                _a[0]; var mediaQuery = _a[1];\n                return mediaQuery.removeListener(handler);\n            });\n        };\n    }, [value, mediaQueryList]);\n    return value;\n}\n\nfunction usePrevious(value) {\n    var ref = React.useRef();\n    React.useEffect(function () {\n        ref.current = value;\n    });\n    return ref.current;\n}\n\nfunction useDidUpdateEffect(effect, deps) {\n    var didMountRef = React.useRef(false);\n    // eslint-disable-next-line consistent-return\n    React.useEffect(function () {\n        if (didMountRef.current) {\n            var cleanup_1 = effect();\n            if (cleanup_1) {\n                return function () { return cleanup_1(); };\n            }\n        }\n        didMountRef.current = true;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n\nvar UseLoadingStates;\n(function (UseLoadingStates) {\n    UseLoadingStates[\"LOADED\"] = \"loaded\";\n    UseLoadingStates[\"LOADING\"] = \"loading\";\n    UseLoadingStates[\"ERROR\"] = \"error\";\n})(UseLoadingStates || (UseLoadingStates = {}));\n\n/**\n * Возвращает результат загрузки изображения\n * @param params.src url изображения\n * @return результат загрузки (loading | loaded | error)\n */\nfunction useImageLoadingState(_a) {\n    var src = _a.src;\n    var _b = useState(UseLoadingStates.LOADING), loadingState = _b[0], setLoadingState = _b[1];\n    useEffect(function () {\n        var active = true;\n        setLoadingState(UseLoadingStates.LOADING);\n        var image = new Image();\n        image.onload = function () {\n            if (!active) {\n                return;\n            }\n            setLoadingState(UseLoadingStates.LOADED);\n        };\n        image.onerror = function () {\n            if (!active) {\n                return;\n            }\n            setLoadingState(UseLoadingStates.ERROR);\n        };\n        image.srcset = src;\n        return function () {\n            active = false;\n        };\n    }, [src]);\n    return loadingState;\n}\n\nfunction useScrolledToBottomOfPage(cb, once) {\n    if (once === void 0) { once = true; }\n    React.useEffect(function () {\n        var handler = function () {\n            if (hasScrolledToBottomOfPage()) {\n                cb();\n                if (once) {\n                    document.removeEventListener('scroll', handler);\n                }\n            }\n        };\n        document.addEventListener('scroll', handler);\n        return function () {\n            document.removeEventListener('scroll', handler);\n        };\n    }, [cb]);\n}\n\nfunction useForceUpdate() {\n    var _a = useState(Object.create(null)), dispatch = _a[1];\n    var memoizedDispatch = useCallback(function () {\n        dispatch(Object.create(null));\n    }, [dispatch]);\n    return memoizedDispatch;\n}\n\n/**\n * Хук получения состояния доступности компонента.\n */\nvar useIsMounted = function () {\n    var isMounted = useRef(true);\n    useEffect(function () { return function () {\n        isMounted.current = false;\n    }; }, []);\n    return useCallback(function () { return isMounted.current; }, []);\n};\n\nvar useId = React.useId || function useUuid() {\n    /*\n     * Utilize useState instead of useMemo because React\n     * makes no guarantees that the memo store is durable\n     */\n    var id = React.useState(function () { return v4(); })[0];\n    return id;\n};\n\n/**\n * Обновление состояния, только если компонент смонтирован\n * Устраняет утечку и варнинги\n */\nvar useStateIfMounted = function (initialValue) {\n    var getIsMounted = useIsMounted();\n    var _a = React.useState(initialValue), storedValue = _a[0], setStoredValue = _a[1];\n    var setState = React.useCallback(function (value) {\n        var isMounted = getIsMounted();\n        if (isMounted) {\n            setStoredValue(value);\n        }\n    }, [getIsMounted]);\n    return [storedValue, setState];\n};\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar useLayoutEffect_SAFE_FOR_SSR = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport { useClickOutside, useCountdown, useDidUpdateEffect, useDimensions, useEventCallback, useFocus, useForceUpdate, useId, useImageLoadingState, useIsMounted, useKeydownOutside, useLayoutEffect_SAFE_FOR_SSR, useMedia, usePrevious, useScrolledToBottomOfPage, useStateIfMounted };\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\n *\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n */\n(function() {\n'use strict';\n\n// Exit early if we're not running in a browser.\nif (typeof window !== 'object') {\n  return;\n}\n\n// Exit early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/w3c/IntersectionObserver/issues/211\n  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(window.IntersectionObserverEntry.prototype,\n      'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  return;\n}\n\n/**\n * Returns the embedding frame element, if any.\n * @param {!Document} doc\n * @return {!Element}\n */\nfunction getFrameElement(doc) {\n  try {\n    return doc.defaultView && doc.defaultView.frameElement || null;\n  } catch (e) {\n    // Ignore the error.\n    return null;\n  }\n}\n\n/**\n * A local reference to the root document.\n */\nvar document = (function(startDoc) {\n  var doc = startDoc;\n  var frame = getFrameElement(doc);\n  while (frame) {\n    doc = frame.ownerDocument;\n    frame = getFrameElement(doc);\n  }\n  return doc;\n})(window.document);\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observing a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n/**\n * The signal updater for cross-origin intersection. When not null, it means\n * that the polyfill is configured to work in a cross-origin mode.\n * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nvar crossOriginUpdater = null;\n\n/**\n * The current cross-origin intersection. Only used in the cross-origin mode.\n * @type {DOMRect|ClientRect}\n */\nvar crossOriginRect = null;\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = ensureDOMRect(entry.rootBounds);\n  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);\n  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n\n  // Sets intersection ratio.\n  if (targetArea) {\n    // Round the intersection ratio to avoid floating point math issues:\n    // https://github.com/w3c/IntersectionObserver/issues/324\n    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\n  } else {\n    // If area is zero and is intersecting, sets to 1, otherwise to 0\n    this.intersectionRatio = this.isIntersecting ? 1 : 0;\n  }\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (\n    options.root &&\n    options.root.nodeType != 1 &&\n    options.root.nodeType != 9\n  ) {\n    throw new Error('root must be a Document or Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n\n  /** @private @const {!Array<!Document>} */\n  this._monitoringDocuments = [];\n  /** @private @const {!Array<function()>} */\n  this._monitoringUnsubscribes = [];\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n/**\n * Use a mutation observer on the root element\n * to detect intersection changes.\n */\nIntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\n\n\n/**\n * Sets up the polyfill in the cross-origin mode. The result is the\n * updater function that accepts two arguments: `boundingClientRect` and\n * `intersectionRect` - just as these fields would be available to the\n * parent via `IntersectionObserverEntry`. This function should be called\n * each time the iframe receives intersection information from the parent\n * window, e.g. via messaging.\n * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}\n */\nIntersectionObserver._setupCrossOriginUpdater = function() {\n  if (!crossOriginUpdater) {\n    /**\n     * @param {DOMRect|ClientRect} boundingClientRect\n     * @param {DOMRect|ClientRect} intersectionRect\n     */\n    crossOriginUpdater = function(boundingClientRect, intersectionRect) {\n      if (!boundingClientRect || !intersectionRect) {\n        crossOriginRect = getEmptyRect();\n      } else {\n        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);\n      }\n      registry.forEach(function(observer) {\n        observer._checkForIntersections();\n      });\n    };\n  }\n  return crossOriginUpdater;\n};\n\n\n/**\n * Resets the cross-origin mode.\n */\nIntersectionObserver._resetCrossOriginUpdater = function() {\n  crossOriginUpdater = null;\n  crossOriginRect = null;\n};\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\n    return item.element == target;\n  });\n\n  if (isTargetAlreadyObserved) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections(target.ownerDocument);\n  this._checkForIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n        return item.element != target;\n      });\n  this._unmonitorIntersections(target.ownerDocument);\n  if (this._observationTargets.length == 0) {\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorAllIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibility state is visible.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function(doc) {\n  var win = doc.defaultView;\n  if (!win) {\n    // Already destroyed.\n    return;\n  }\n  if (this._monitoringDocuments.indexOf(doc) != -1) {\n    // Already monitoring.\n    return;\n  }\n\n  // Private state for monitoring.\n  var callback = this._checkForIntersections;\n  var monitoringInterval = null;\n  var domObserver = null;\n\n  // If a poll interval is set, use polling instead of listening to\n  // resize and scroll events or DOM mutations.\n  if (this.POLL_INTERVAL) {\n    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);\n  } else {\n    addEvent(win, 'resize', callback, true);\n    addEvent(doc, 'scroll', callback, true);\n    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {\n      domObserver = new win.MutationObserver(callback);\n      domObserver.observe(doc, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    }\n  }\n\n  this._monitoringDocuments.push(doc);\n  this._monitoringUnsubscribes.push(function() {\n    // Get the window object again. When a friendly iframe is destroyed, it\n    // will be null.\n    var win = doc.defaultView;\n\n    if (win) {\n      if (monitoringInterval) {\n        win.clearInterval(monitoringInterval);\n      }\n      removeEvent(win, 'resize', callback, true);\n    }\n\n    removeEvent(doc, 'scroll', callback, true);\n    if (domObserver) {\n      domObserver.disconnect();\n    }\n  });\n\n  // Also monitor the parent.\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n  if (doc != rootDoc) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._monitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function(doc) {\n  var index = this._monitoringDocuments.indexOf(doc);\n  if (index == -1) {\n    return;\n  }\n\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n\n  // Check if any dependent targets are still remaining.\n  var hasDependentTargets =\n      this._observationTargets.some(function(item) {\n        var itemDoc = item.element.ownerDocument;\n        // Target is in this context.\n        if (itemDoc == doc) {\n          return true;\n        }\n        // Target is nested in this context.\n        while (itemDoc && itemDoc != rootDoc) {\n          var frame = getFrameElement(itemDoc);\n          itemDoc = frame && frame.ownerDocument;\n          if (itemDoc == doc) {\n            return true;\n          }\n        }\n        return false;\n      });\n  if (hasDependentTargets) {\n    return;\n  }\n\n  // Unsubscribe.\n  var unsubscribe = this._monitoringUnsubscribes[index];\n  this._monitoringDocuments.splice(index, 1);\n  this._monitoringUnsubscribes.splice(index, 1);\n  unsubscribe();\n\n  // Also unmonitor the parent.\n  if (doc != rootDoc) {\n    var frame = getFrameElement(doc);\n    if (frame) {\n      this._unmonitorIntersections(frame.ownerDocument);\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @param {!Document} doc\n * @private\n */\nIntersectionObserver.prototype._unmonitorAllIntersections = function() {\n  var unsubscribes = this._monitoringUnsubscribes.slice(0);\n  this._monitoringDocuments.length = 0;\n  this._monitoringUnsubscribes.length = 0;\n  for (var i = 0; i < unsubscribes.length; i++) {\n    unsubscribes[i]();\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  if (!this.root && crossOriginUpdater && !crossOriginRect) {\n    // Cross origin monitoring, but no initial data available yet.\n    return;\n  }\n\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, targetRect, rootRect);\n\n    var rootBounds = null;\n    if (!this._rootContainsTarget(target)) {\n      rootBounds = getEmptyRect();\n    } else if (!crossOriginUpdater || this.root) {\n      rootBounds = rootRect;\n    }\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootBounds,\n      intersectionRect: intersectionRect\n    });\n\n    if (!oldEntry) {\n      this._queuedEntries.push(newEntry);\n    } else if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} targetRect The bounding rect of the target.\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, targetRect, rootRect) {\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var intersectionRect = targetRect;\n  var parent = getParentNode(target);\n  var atRoot = false;\n\n  while (!atRoot && parent) {\n    var parentRect = null;\n    var parentComputedStyle = parent.nodeType == 1 ?\n        window.getComputedStyle(parent) : {};\n\n    // If the parent isn't displayed, an intersection can't happen.\n    if (parentComputedStyle.display == 'none') return null;\n\n    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {\n      atRoot = true;\n      if (parent == this.root || parent == document) {\n        if (crossOriginUpdater && !this.root) {\n          if (!crossOriginRect ||\n              crossOriginRect.width == 0 && crossOriginRect.height == 0) {\n            // A 0-size cross-origin intersection means no-intersection.\n            parent = null;\n            parentRect = null;\n            intersectionRect = null;\n          } else {\n            parentRect = crossOriginRect;\n          }\n        } else {\n          parentRect = rootRect;\n        }\n      } else {\n        // Check if there's a frame that can be navigated to.\n        var frame = getParentNode(parent);\n        var frameRect = frame && getBoundingClientRect(frame);\n        var frameIntersect =\n            frame &&\n            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);\n        if (frameRect && frameIntersect) {\n          parent = frame;\n          parentRect = convertFromParentRect(frameRect, frameIntersect);\n        } else {\n          parent = null;\n          intersectionRect = null;\n        }\n      }\n    } else {\n      // If the element has a non-visible overflow, and it's not the <body>\n      // or <html> element, update the intersection rect.\n      // Note: <body> and <html> cannot be clipped to a rect that's not also\n      // the document rect, so no need to compute a new intersection.\n      var doc = parent.ownerDocument;\n      if (parent != doc.body &&\n          parent != doc.documentElement &&\n          parentComputedStyle.overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n    }\n    if (!intersectionRect) break;\n    parent = parent && getParentNode(parent);\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {ClientRect} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root && !isDoc(this.root)) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var doc = isDoc(this.root) ? this.root : document;\n    var html = doc.documentElement;\n    var body = doc.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {DOMRect|ClientRect} rect The rect object to expand.\n * @return {ClientRect} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || containsDeep(document, this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  var rootDoc =\n    (this.root && (this.root.ownerDocument || this.root)) || document;\n  return (\n    containsDeep(rootDoc, target) &&\n    (!this.root || rootDoc == target.ownerDocument)\n  );\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its execution, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object|?ClientRect} The intersection rect or undefined if no\n *     intersection is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  } || null;\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect;\n\n  try {\n    rect = el.getBoundingClientRect();\n  } catch (err) {\n    // Ignore Windows 7 IE11 \"Unspecified error\"\n    // https://github.com/w3c/IntersectionObserver/pull/205\n  }\n\n  if (!rect) return getEmptyRect();\n\n  // Older IE\n  if (!(rect.width && rect.height)) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {ClientRect} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n\n/**\n * Ensure that the result has all of the necessary fields of the DOMRect.\n * Specifically this ensures that `x` and `y` fields are set.\n *\n * @param {?DOMRect|?ClientRect} rect\n * @return {?DOMRect}\n */\nfunction ensureDOMRect(rect) {\n  // A `DOMRect` object has `x` and `y` fields.\n  if (!rect || 'x' in rect) {\n    return rect;\n  }\n  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case\n  // for internally calculated Rect objects. For the purposes of\n  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`\n  // for these fields.\n  return {\n    top: rect.top,\n    y: rect.top,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    right: rect.right,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n\n/**\n * Inverts the intersection and bounding rect from the parent (frame) BCR to\n * the local BCR space.\n * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.\n * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.\n * @return {ClientRect} The local root bounding rect for the parent's children.\n */\nfunction convertFromParentRect(parentBoundingRect, parentIntersectionRect) {\n  var top = parentIntersectionRect.top - parentBoundingRect.top;\n  var left = parentIntersectionRect.left - parentBoundingRect.left;\n  return {\n    top: top,\n    left: left,\n    height: parentIntersectionRect.height,\n    width: parentIntersectionRect.width,\n    bottom: top + parentIntersectionRect.height,\n    right: left + parentIntersectionRect.width\n  };\n}\n\n\n/**\n * Checks to see if a parent element contains a child element (including inside\n * shadow DOM).\n * @param {Node} parent The parent element.\n * @param {Node} child The child element.\n * @return {boolean} True if the parent node contains the child node.\n */\nfunction containsDeep(parent, child) {\n  var node = child;\n  while (node) {\n    if (node == parent) return true;\n\n    node = getParentNode(node);\n  }\n  return false;\n}\n\n\n/**\n * Gets the parent node of an element or its host element if the parent node\n * is a shadow root.\n * @param {Node} node The node whose parent to get.\n * @return {Node|null} The parent node or null if no parent exists.\n */\nfunction getParentNode(node) {\n  var parent = node.parentNode;\n\n  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {\n    // If this node is a document node, look for the embedding frame.\n    return getFrameElement(node);\n  }\n\n  // If the parent has element that is assigned through shadow root slot\n  if (parent && parent.assignedSlot) {\n    parent = parent.assignedSlot.parentNode\n  }\n\n  if (parent && parent.nodeType == 11 && parent.host) {\n    // If the parent is a shadow root, return the host element.\n    return parent.host;\n  }\n\n  return parent;\n}\n\n/**\n * Returns true if `node` is a Document.\n * @param {!Node} node\n * @returns {boolean}\n */\nfunction isDoc(node) {\n  return node && node.nodeType === 9;\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}());\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n"],"names":["UseLoadingStates","getValue","list","map","_a","value","matches","filter","Boolean","useMedia","defaultValue","React","setValue","_b","mediaQueryList","setMediaQueryList","isClient","window","matchMedia","queryList","x","y","handler","forEach","addListener","removeListener","document","useLayoutEffect","useEffect","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","IntersectionObserverEntry","get","this","intersectionRatio","startDoc","doc","frame","getFrameElement","ownerDocument","registry","crossOriginUpdater","crossOriginRect","IntersectionObserver","THROTTLE_TIMEOUT","POLL_INTERVAL","USE_MUTATION_OBSERVER","_setupCrossOriginUpdater","boundingClientRect","intersectionRect","convertFromParentRect","top","bottom","left","right","width","height","observer","_checkForIntersections","_resetCrossOriginUpdater","observe","_observationTargets","some","item","element","nodeType","Error","_registerInstance","push","entry","_monitorIntersections","unobserve","_unmonitorIntersections","_unregisterInstance","disconnect","_unmonitorAllIntersections","takeRecords","records","_queuedEntries","slice","_initThresholds","opt_threshold","threshold","Array","isArray","sort","t","a","isNaN","_parseRootMargin","opt_rootMargin","margins","split","margin","parts","exec","parseFloat","unit","win","defaultView","_monitoringDocuments","indexOf","callback","monitoringInterval","domObserver","setInterval","addEvent","MutationObserver","attributes","childList","characterData","subtree","_monitoringUnsubscribes","clearInterval","removeEvent","rootDoc","root","index","hasDependentTargets","itemDoc","unsubscribe","splice","unsubscribes","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","targetRect","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","rootBounds","newEntry","time","performance","now","_hasCrossedThreshold","isIntersecting","_callback","getComputedStyle","display","rect1","rect2","parent","getParentNode","atRoot","parentRect","parentComputedStyle","frameRect","frameIntersect","body","documentElement","overflow","Math","max","min","isDoc","html","clientWidth","clientHeight","_expandRectByRootMargin","rect","_rootMarginValues","newRect","oldRatio","newRatio","thresholds","containsDeep","frameElement","e","ensureDOMRect","targetArea","intersectionArea","Number","toFixed","opt_options","options","throttle","fn","timeout","timer","setTimeout","bind","rootMargin","join","node","event","opt_useCapture","addEventListener","attachEvent","removeEventListener","detatchEvent","el","err","parentBoundingRect","parentIntersectionRect","child","parentNode","assignedSlot","host","hasOwnProperty","obj","prop","call","module","exports","qs","sep","eq","regexp","maxKeys","len","kstr","vstr","k","v","replace","idx","substr","decodeURIComponent","stringifyPrimitive","isFinite","name","undefined","keys","ks","encodeURIComponent","decode","parse","encode","stringify"],"sourceRoot":""}